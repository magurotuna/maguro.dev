---
title: "なぜJavaScriptのfetchはawaitを2回しないとレスポンスを取れないのか"
date: 2026-01-17
tags: ["JavaScript", "fetch", "HTTP"]
description: "fetchでawaitを2回する設計の背景と、他言語HTTPクライアントとの比較"
---

JavaScriptの `fetch` を使ったことがある人なら、こんなコードを書いたことがあると思います。

```javascript
const response = await fetch("https://api.example.com/data");
const data = await response.json();
```

`await` を2回書いているのが気になったことはありませんか？1回の `await` で一気にレスポンスボディまで取れたら楽なのに、と思ったことはないでしょうか。

とある休日の午前中、いつものようにYouTube上でライブコーディングを垂れ流していました[^1]。そこで配信者の方が、`fetch`を使ってレスポンスボディを取得する際に2回目の`await`が必要であることに対して、「なんでfetchはこんなにめんどくさいんだろう」と言っていました。言われてみると、確かにめんどくさいような気もします。

[^1]: ライブコーディング動画を見るのが好きです。過去に [YouTubeにあるライブコーディング動画を見て Rust を学ぼう](https://zenn.dev/magurotuna/articles/d5621291b8da87) や [【#も読】ライブコーディング視聴のすすめ（@yusuktan）](https://findy-code.io/media/articles/modoku20250519-yusuktan) などを書いています。

この記事では、なぜ `fetch` がこのような設計になっているのかを掘り下げてみます。

## TL;DR

- `fetch` は**ストリーミングを前提とした設計**になっている
- 1回目の `await` でレスポンスヘッダーを取得し、2回目の `await` でボディを取得する
- もし1回の `await` でヘッダーとボディを一気に取得する設計だったら、**無限に続くストリーミングレスポンス（SSE など）を扱えなくなる**
- この設計は Rust の reqwest や Python の aiohttp など、他言語の HTTP クライアントでも採用されている

## 基本的なパターン

まずは基本的な使い方を確認しておきましょう。

```javascript
// 1回目の await: レスポンスヘッダーが届くまで待つ
const response = await fetch("https://api.example.com/users");

// この時点でヘッダーにはアクセスできる
console.log(response.status);        // 200
console.log(response.headers.get("Content-Type")); // application/json

// 2回目の await: レスポンスボディを読み取る
const users = await response.json();
```

`fetch()` が返す Promise は、**レスポンスヘッダーが届いた時点で解決**されます。この時点ではまだボディは読み取れていません。ボディを読むには `.json()` や `.text()` といったメソッドを呼ぶ必要があり、これらも Promise を返すので再度 `await` が必要になります。

## もし await が1回で済む設計だったら

「1回の `await` でヘッダーもボディも全部取れたら便利なのに」という気持ちはわかります。実際、多くのケースではそれで問題ないでしょう。

```javascript
// 仮想的なAPI: 1回のawaitでボディまで取得
const { headers, body } = await fetch("https://api.example.com/users");
```

しかし、この設計には重大な問題があります。

### 問題1: 巨大なレスポンスボディ

レスポンスボディが数GBあるファイルだったらどうでしょうか？

1回の `await` でボディまで取得する設計だと、全データがメモリに読み込まれるまで待つことになります。時間がかかるだけでなく、メモリを大量に消費してしまいます。

現在の設計なら、ヘッダーを見てからボディを**ストリームとして少しずつ処理**できます。

```javascript
const response = await fetch("https://example.com/huge-file.zip");

// Content-Length を確認してから処理を決められる
const size = response.headers.get("Content-Length");
console.log(`ファイルサイズ: ${size} bytes`);

// ストリームとして少しずつ処理
const reader = response.body.getReader();
while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  // value (Uint8Array) を少しずつ処理
}
```

### 問題2: 終わらないストリーミングレスポンス

さらに深刻なのが、**レスポンスボディが永遠に終わらないケース**です。

代表例が **Server-Sent Events (SSE)** です。SSE はサーバーからクライアントへリアルタイムにデータをプッシュする仕組みで、ChatGPT や Claude の API でストリーミングレスポンスを受け取るときにも使われています。

```javascript
// SSE エンドポイントへのリクエスト
const response = await fetch("https://api.example.com/events", {
  headers: { "Accept": "text/event-stream" }
});

// ストリームとして読み取る
const reader = response.body.getReader();
const decoder = new TextDecoder();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;

  const chunk = decoder.decode(value);
  console.log("受信:", chunk);
  // data: {"message": "Hello"}
  // data: {"message": "World"}
  // ...（サーバーが送り続ける限り続く）
}
```

SSE のレスポンスは、サーバーが接続を閉じるか、クライアントが明示的に中断するまで終わりません。

もし1回の `await` でヘッダーとボディを全部取得する設計だったら、この `await` は**永遠に完了しない**ことになります。これでは使い物になりません。

現在の設計なら、ヘッダーが届いた時点で `await` が完了し、そこからストリームを少しずつ読んでいくことができます。

## JavaScript エコシステムの HTTP クライアントライブラリ

`fetch` の「2回 await」が面倒だと感じる人は多いようで、npm には様々な HTTP クライアントライブラリがあります。これらは `fetch` の設計をどう扱っているのでしょうか？

### axios

[axios](https://github.com/axios/axios) は最も人気のある HTTP クライアントライブラリの1つです。axios では1回の `await` でレスポンスボディまで取得できます。

```javascript
const response = await axios.get("https://api.example.com/users");
// response.data にはすでにパース済みの JSON オブジェクトが入っている
console.log(response.data);
```

axios は内部でレスポンス全体をバッファリングし、`Content-Type` を見て自動的に JSON をパースしてくれます。便利ですが、これは**ストリーミングに対応していない**ことを意味します。

大きなファイルのダウンロードやSSEを扱う場合は、`responseType: 'stream'`（Node.js）を指定する必要があります。

```javascript
// Node.js でのストリーミング
const response = await axios.get("https://example.com/large-file.zip", {
  responseType: "stream"
});
response.data.pipe(fs.createWriteStream("large-file.zip"));
```

ブラウザでは axios のストリーミングサポートは限定的で、[公式ドキュメント](https://blog.logrocket.com/axios-vs-fetch-2025/)でも「fetch supports streaming responses on the browser, unlike Axios」と言及されています。

### ky

[ky](https://github.com/sindresorhus/ky) は `fetch` のラッパーとして設計された軽量ライブラリです。`fetch` の設計思想を尊重しつつ、より使いやすい API を提供しています。

```javascript
// ky では .json() を直接チェーンできる
const data = await ky.get("https://api.example.com/users").json();

// 上記は以下と同じ
const response = await ky.get("https://api.example.com/users");
const data = await response.json();
```

ky は `fetch` ベースなので、ストリーミングも自然に扱えます。

```javascript
const response = await ky.get("https://example.com/stream");
const reader = response.body.getReader();
// 以降は fetch と同じ
```

ky の `.json()` は内部的には2回の非同期処理を行っていますが、チェーンして書けるので見た目はシンプルになります。ただし、ヘッダーを先に確認してからボディを読むかどうか決めたい場合は、やはり2段階に分けて書く必要があります。

### got

[got](https://github.com/sindresorhus/got) は Node.js 向けの高機能な HTTP クライアントです。Promise API とストリーム API の両方を提供しています。

```javascript
// Promise API: レスポンス全体をバッファリング
const response = await got("https://api.example.com/users");
console.log(response.body); // 文字列

// JSON の場合
const data = await got("https://api.example.com/users").json();
```

got の Promise API は便利ですが、レスポンス全体をメモリに読み込みます。大きなファイルやストリーミングを扱う場合は、明示的にストリーム API を使います。

```javascript
import { pipeline } from "node:stream/promises";
import { createWriteStream } from "node:fs";
import got from "got";

// ストリーム API: メモリ効率が良い
await pipeline(
  got.stream("https://example.com/large-file.zip"),
  createWriteStream("large-file.zip")
);
```

[got のドキュメント](https://github.com/sindresorhus/got/blob/main/documentation/3-streams.md)には次のように書かれています。

> The promise API will load responses into memory until the response is finished before fulfilling the promise, but with the stream API you can act on chunks of the response as they arrive.

### superagent

[superagent](https://github.com/ladjs/superagent) は古くからある HTTP クライアントで、Node.js とブラウザの両方で動作します。

```javascript
const response = await superagent.get("https://api.example.com/users");
console.log(response.body); // パース済みの JSON
```

superagent もデフォルトではレスポンス全体をバッファリングしますが、ストリーミングも可能です。

```javascript
// ストリーミングダウンロード
superagent
  .get("https://example.com/large-file.zip")
  .pipe(fs.createWriteStream("large-file.zip"));
```

ただし、[公式ドキュメント](https://ladjs.github.io/superagent/)には「It's not possible to mix pipes and callbacks or promises」と書かれており、ストリーミングと Promise を同時に使うことはできません。

### undici

[undici](https://github.com/nodejs/undici) は Node.js の公式 HTTP クライアントで、Node.js 18 以降の組み込み `fetch` の内部実装にも使われています。

```javascript
import { request } from "undici";

const { statusCode, headers, body } = await request("https://api.example.com/users");

// body は AsyncIterable
let data = "";
for await (const chunk of body) {
  data += chunk;
}
console.log(JSON.parse(data));
```

undici は `fetch` と同様、レスポンスヘッダーが届いた時点で Promise が解決され、ボディは後から読み取る設計になっています。

### まとめ: ライブラリごとの設計方針

| ライブラリ | await 1回で完結 | ストリーミング対応 | 備考 |
|-----------|----------------|------------------|------|
| fetch (native) | No | Yes | 標準 API、2回 await が必要 |
| axios | Yes | 限定的 | 便利だがブラウザでのストリーミングは弱い |
| ky | Yes（チェーン時） | Yes | fetch ラッパー、ストリーミングも自然に扱える |
| got | Yes | Yes | Promise API とストリーム API を使い分け |
| superagent | Yes | Yes | ストリーミング時は Promise と併用不可 |
| undici | No | Yes | fetch と同じ設計思想 |

多くのライブラリは「1回の await で済む」便利な API を提供していますが、その裏ではレスポンス全体をメモリにバッファリングしています。ストリーミングが必要な場合は、結局 `fetch` と同様に2段階の処理が必要になるか、別のストリーム専用 API を使うことになります。

## 他の言語の HTTP クライアントはどうしているか

この「ヘッダーとボディを分けて取得する」設計は、実は `fetch` 特有のものではありません。他の言語の HTTP クライアントも同様の設計を採用しています。

### Rust (reqwest / hyper)

Rust の reqwest も同じパターンです。

```rust
// 1回目の await: レスポンスヘッダーを取得
let response = reqwest::get("https://api.example.com/data").await?;

// ヘッダーにアクセス可能
println!("Status: {}", response.status());

// 2回目の await: ボディを取得
let body = response.text().await?;
```

reqwest の内部で使われている hyper も同様で、HTTP レスポンスはヘッダーとボディが分離されています。ストリーミングを扱う場合は `.chunk()` や `.bytes_stream()` を使います。

### Python (aiohttp)

Python の aiohttp も明確にこの設計思想を持っています。[公式ドキュメント](https://docs.aiohttp.org/en/stable/http_request_lifecycle.html)には次のように書かれています。

> aiohttp loads only the headers when `.get()` is executed, letting you decide to pay the cost of loading the body afterward, in a second asynchronous operation.

```python
async with aiohttp.ClientSession() as session:
    # 1回目の await: ヘッダーを取得
    async with session.get("https://api.example.com/data") as response:
        print(response.status)

        # 2回目の await: ボディを取得
        data = await response.json()
```

### Go

Go は async/await の構文を持たないので少し違って見えますが、本質的には同じです。`http.Client.Do()` はレスポンスヘッダーが届いた時点でリターンし、ボディは `io.Reader` として提供されます。

```go
resp, err := http.Get("https://api.example.com/data")
if err != nil {
    log.Fatal(err)
}
defer resp.Body.Close()

// この時点でヘッダーにアクセス可能
fmt.Println("Status:", resp.Status)

// ボディは io.Reader として提供される
// 読み取りは同期的だが、ストリームとして少しずつ処理できる
body, err := io.ReadAll(resp.Body)
```

### Java (HttpClient)

Java 11 以降の HttpClient は、[`BodyHandler`](https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandler.html) という仕組みでこれを実現しています。

> The BodyHandler is invoked when the response status code and headers are available, but before the response body bytes are received.

```java
HttpClient client = HttpClient.newHttpClient();
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com/data"))
    .build();

// BodyHandlers.ofInputStream() を使うと、
// ヘッダーが届いた時点でレスポンスが返り、
// ボディは InputStream として後から読める
HttpResponse<InputStream> response = client.send(request,
    HttpResponse.BodyHandlers.ofInputStream());

System.out.println("Status: " + response.statusCode());

// ボディはストリームとして読み取る
try (InputStream body = response.body()) {
    // ...
}
```

### C# (HttpClient)

C# の HttpClient は [`HttpCompletionOption.ResponseHeadersRead`](https://www.stevejgordon.co.uk/using-httpcompletionoption-responseheadersread-to-improve-httpclient-performance-dotnet) というオプションでこの動作を明示的に制御できます。

```csharp
using var client = new HttpClient();

// ResponseHeadersRead を指定すると、ヘッダーが届いた時点でタスクが完了
var response = await client.GetAsync(
    "https://api.example.com/data",
    HttpCompletionOption.ResponseHeadersRead);

Console.WriteLine($"Status: {response.StatusCode}");

// ボディはストリームとして読み取る
await using var stream = await response.Content.ReadAsStreamAsync();
```

デフォルトでは `ResponseContentRead`（ボディまで全部読んでから完了）ですが、ストリーミングや大きなレスポンスを扱う場合は `ResponseHeadersRead` を使うのがベストプラクティスとされています。

## Fetch 仕様はどう定めているか

[WHATWG の Fetch 仕様](https://fetch.spec.whatwg.org/)では、レスポンスボディは `ReadableStream` として定義されており、ストリーミング処理を前提とした設計になっています。

仕様には "incrementally read a body"（ボディを漸進的に読む）というアルゴリズムが定義されていて、ボディを全部バッファリングしてから返すのではなく、少しずつ読み取ることが意図されていることがわかります。

### 仕様策定時の議論

WHATWG の GitHub リポジトリには、この設計に関連するいくつかの議論が残っています。

[Issue #88](https://github.com/whatwg/fetch/issues/88) では、開発者がリクエスト/レスポンスのストリームを制御できるようにする議論が行われました。HTTP の専門家である Mark Nottingham 氏は、サーバー側の制約（多くのサーバーは `Content-Length` がないと無限にバッファリングしようとしてしまう）なども踏まえた設計の必要性を指摘しています。

[Issue #1254](https://github.com/whatwg/fetch/issues/1254) では、HTTP/2 や QUIC の全二重ストリーミングを `fetch` で活用できないかという議論がありました。現状の `fetch` はリクエストボディの送信が完了してからレスポンスの Promise が解決される設計ですが、将来的にはリクエストとレスポンスを並行してストリーミングできるようになるかもしれません。

## まとめ

`fetch` で `await` を2回する必要があるのは、**ストリーミングを適切に扱うため**の意図的な設計です。

- 1回目の `await`: レスポンスヘッダーが届くまで待つ
- 2回目の `await`: ボディを（全部または一部）読み取る

この設計により、以下のことが可能になります。

- ヘッダーを見てからボディの処理方法を決められる
- 巨大なレスポンスをメモリに全部載せずにストリーム処理できる
- SSE のような終わらないストリーミングレスポンスを扱える

`await` を2回書くのは少し冗長に感じるかもしれませんが、その背後にはHTTPという通信の性質上、どうしてもそうならざるを得ない理由があるのでした。

## 参考資料

- [Fetch Standard - WHATWG](https://fetch.spec.whatwg.org/)
- [Using the Fetch API - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)
- [Using readable streams - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams)
- [Axios vs. Fetch (2025 update) - LogRocket Blog](https://blog.logrocket.com/axios-vs-fetch-2025/)
- [ky - GitHub](https://github.com/sindresorhus/ky)
- [got Streams documentation](https://github.com/sindresorhus/got/blob/main/documentation/3-streams.md)
- [SuperAgent documentation](https://ladjs.github.io/superagent/)
- [undici - GitHub](https://github.com/nodejs/undici)
- [The aiohttp Request Lifecycle](https://docs.aiohttp.org/en/latest/http_request_lifecycle.html)
- [Response in reqwest - Rust](https://docs.rs/reqwest/latest/reqwest/struct.Response.html)
- [Using HttpCompletionOption to Improve HttpClient Performance in .NET](https://www.stevejgordon.co.uk/using-httpcompletionoption-responseheadersread-to-improve-httpclient-performance-dotnet)
- [HttpResponse.BodyHandler (Java SE 11)](https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandler.html)
- [Developer-controlled streams for request/response - Issue #88](https://github.com/whatwg/fetch/issues/88)
- [Fetch body streams are not full duplex - Issue #1254](https://github.com/whatwg/fetch/issues/1254)
